<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - Long Division</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --input-focus-bg: #e3f2fd;
            --correct-color: #2ecc71;
            --wrong-color: #e74c3c;
            --grid-cell-size: 36px;
            --border-thickness: 2px;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            user-select: none;
        }

        #game-container {
            background: white;
            padding: 20px;
            border: 2px solid #000;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        /* Controls Area */
        .top-controls {
            width: 100%;
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
        }

        select.level-select {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 5px;
            border: 2px solid #000;
            background: #eee;
            cursor: pointer;
        }

        .header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .error-stat {
            color: var(--wrong-color);
        }

        /* The Grid */
        #division-stage {
            display: grid;
            gap: 0; 
            margin-bottom: 20px;
            font-size: 2rem;
            position: relative;
            background: #fff;
            padding: 10px;
            overflow-x: auto;
        }

        .cell {
            width: var(--grid-cell-size);
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            box-sizing: border-box;
        }

        /* Long Division Symbols */
        .cell.bracket-cell {
            border-right: var(--border-thickness) solid black;
            border-radius: 0 6px 0 0;
            margin-right: -1px;
        }
        .cell.dividend-cell {
            border-top: var(--border-thickness) solid black;
            margin-top: -1px;
        }
        .cell.subtract-line {
            border-bottom: var(--border-thickness) solid black;
        }

        /* Special Math Symbols */
        .cell.minus-sign {
            font-weight: bold;
            color: #444;
        }
        
        .cell.arrow-hint {
            color: #2980b9;
            animation: bounce 1s infinite;
            font-size: 1.5rem;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* Input / Target Styling */
        .cell.active-target {
            background-color: var(--input-focus-bg);
            box-shadow: inset 0 0 0 2px #2196f3;
            border: 1px dashed #999; 
            margin: 1px;
            width: calc(var(--grid-cell-size) - 2px);
            height: calc(45px - 2px);
        }
        
        .cell.preview-input {
            color: #000;
            font-weight: bold;
            background-color: #fff;
        }
        
        .cell.preview-input.error {
            color: var(--wrong-color);
            background-color: #fadbd8;
        }

        /* Remainder "R" label style */
        .cell.remainder-label {
            font-size: 1.5rem;
            color: #666;
            font-weight: bold;
        }

        /* Feedback Area */
        #feedback-area {
            height: 50px;
            width: 100%;
            text-align: center;
            font-size: 1.3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f4f4f4;
            border: 1px solid #ccc;
            margin-bottom: 15px;
            color: #555;
            padding: 0 10px;
        }
        #feedback-area.correct { color: var(--correct-color); font-weight: bold; background: #e8f8f5; border-color: var(--correct-color); }
        #feedback-area.wrong { color: var(--wrong-color); font-weight: bold; background: #fdedec; border-color: var(--wrong-color); }

        /* Step Indicators */
        .step-indicators {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            font-size: 1.1rem;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .step-badge {
            padding: 4px 8px;
            background: #eee;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #999;
        }
        
        .step-badge.active {
            background: #2c3e50;
            color: #fff;
            border-color: #000;
            font-weight: bold;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        /* Keypad */
        #keypad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 320px;
        }

        .key {
            background: #e0e0e0;
            border: 1px solid #999;
            border-bottom: 3px solid #777;
            padding: 12px;
            font-size: 1.8rem;
            cursor: pointer;
            text-align: center;
            border-radius: 4px;
            transition: all 0.1s;
        }
        .key:active {
            transform: translateY(2px);
            border-bottom: 1px solid #777;
            background: #d5d5d5;
        }
        .key.action { background: #d4e6f1; border-color: #a9cce3; border-bottom-color: #5499c7; }
        .key.clear { background: #fadbd8; border-color: #e6b0aa; border-bottom-color: #cd6155; }

        .controls {
            margin-top: 15px;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        
        .btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
        }

        #success-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #final-score-msg {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #444;
        }
        
        #success-overlay h2 { font-size: 4rem; margin: 0; color: #27ae60; text-shadow: 2px 2px 0 #fff; }

        @media (max-width: 400px) {
            :root { --grid-cell-size: 30px; }
            #division-stage { font-size: 1.6rem; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="success-overlay">
            <h2>DONE!</h2>
            <p id="final-score-msg">Score +10</p>
            <button class="btn" style="font-size: 1.5rem; padding: 15px 30px;" onclick="game.nextProblem()">Next ▶</button>
        </div>

        <div class="top-controls">
            <select id="level-select" class="level-select" onchange="game.changeLevel()">
                <option value="1">Level 1 (2D ÷ 1D)</option>
                <option value="2">Level 2 (3D ÷ 1D)</option>
                <option value="3">Level 3 (4D ÷ 1D)</option>
                <option value="4">Level 4 (4D ÷ 2D)</option>
            </select>
        </div>

        <div class="header">
            <div class="stat-box">
                <span style="font-size: 1rem; color:#666;">PROBLEM</span>
                <span id="problem-count">1</span>
            </div>
            <div class="stat-box">
                <span style="font-size: 1rem; color:#666;">ERRORS</span>
                <span id="error-display" class="error-stat">0</span>
            </div>
            <div class="stat-box">
                <span style="font-size: 1rem; color:#666;">SCORE</span>
                <span id="score-display">0</span>
            </div>
        </div>

        <div class="step-indicators">
            <div class="step-badge" id="badge-divide">÷ DIVIDE</div>
            <div class="step-badge" id="badge-multiply">× MULTIPLY</div>
            <div class="step-badge" id="badge-subtract">− SUBTRACT</div>
            <div class="step-badge" id="badge-bring">↓ BRING</div>
            <div class="step-badge" id="badge-remainder">R REMAINDER</div>
        </div>

        <div id="feedback-area">Loading...</div>

        <div id="division-stage"></div>

        <div id="keypad">
            <div class="key" onclick="game.handleInput('1')">1</div>
            <div class="key" onclick="game.handleInput('2')">2</div>
            <div class="key" onclick="game.handleInput('3')">3</div>
            <div class="key" onclick="game.handleInput('4')">4</div>
            <div class="key" onclick="game.handleInput('5')">5</div>
            <div class="key" onclick="game.handleInput('6')">6</div>
            <div class="key" onclick="game.handleInput('7')">7</div>
            <div class="key" onclick="game.handleInput('8')">8</div>
            <div class="key" onclick="game.handleInput('9')">9</div>
            <div class="key clear" onclick="game.clearInput()">DEL</div>
            <div class="key" onclick="game.handleInput('0')">0</div>
            <div class="key action" onclick="game.submitInput()">ENTER</div>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="game.skipProblem()">Skip Problem</button>
        </div>
    </div>

<script>

class LongDivisionGame {
    constructor() {
        this.stage = document.getElementById('division-stage');
        this.feedback = document.getElementById('feedback-area');
        this.scoreDisplay = document.getElementById('score-display');
        this.errorDisplay = document.getElementById('error-display');
        this.problemCountDisplay = document.getElementById('problem-count');
        this.levelSelect = document.getElementById('level-select');
        this.finalScoreMsg = document.getElementById('final-score-msg');
        
        this.badges = {
            divide: document.getElementById('badge-divide'),
            multiply: document.getElementById('badge-multiply'),
            subtract: document.getElementById('badge-subtract'),
            bring: document.getElementById('badge-bring'),
            remainder: document.getElementById('badge-remainder')
        };
        
        this.score = 0;
        this.problemNumber = 1;
        this.level = 1;
        this.errors = 0;
        this.userInput = ''; 
        
        this.init();
        this.setupKeyboard();
    }

    init() {
        this.nextProblem();
    }

    setupKeyboard() {
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('success-overlay').style.display === 'flex') {
                if (e.key === 'Enter') this.nextProblem();
                return;
            }

            if (e.key >= '0' && e.key <= '9') {
                this.handleInput(e.key);
            } else if (e.key === 'Enter') {
                this.submitInput();
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                this.clearInput();
            }
        });
    }

    changeLevel() {
        this.level = parseInt(this.levelSelect.value);
        this.problemNumber = 1;
        this.score = 0;
        this.scoreDisplay.textContent = '0';
        this.nextProblem();
    }

    generateProblem() {
        let divMin, divMax, dMin, dMax;
        
        switch(this.level) {
            case 1: // 2-digit div / 1-digit
                dMin = 2; dMax = 9;
                divMin = 20; divMax = 99;
                break;
            case 2: // 3-digit div / 1-digit
                dMin = 2; dMax = 9;
                divMin = 100; divMax = 999;
                break;
            case 3: // 4-digit div / 1-digit
                dMin = 2; dMax = 9;
                divMin = 1000; divMax = 9999;
                break;
            case 4: // 4-digit div / 2-digit
                dMin = 10; dMax = 25; // Keeping it simpler for now (10-25)
                divMin = 1000; divMax = 9999;
                break;
            default: 
                dMin = 2; dMax = 9;
                divMin = 20; divMax = 99;
        }

        const divisor = Math.floor(Math.random() * (dMax - dMin + 1)) + dMin;
        const dividend = Math.floor(Math.random() * (divMax - divMin + 1)) + divMin;
        
        // Ensure not trivial (e.g. 20 / 25 or 1000 / 900)
        if (dividend < divisor * 2) return this.generateProblem();

        return {
            divisor: divisor,
            dividend: dividend,
            dividendStr: dividend.toString()
        };
    }

    nextProblem() {
        document.getElementById('success-overlay').style.display = 'none';
        this.problemData = this.generateProblem();
        this.problemCountDisplay.textContent = this.problemNumber;
        this.errors = 0;
        this.errorDisplay.textContent = this.errors;
        
        this.state = {
            step: 'DIVIDE', // DIVIDE, MULTIPLY, SUBTRACT, BRING_DOWN, REMAINDER
            dividendIndex: 0,
            currentRemainder: 0,
            workingValue: 0, 
            currentRow: 2 
        };

        // Smart Start Logic: Grab enough digits to be >= divisor
        let tempVal = 0;
        let idx = -1;
        const dStr = this.problemData.dividendStr;
        const divisor = this.problemData.divisor;

        // Loop until we have a chunk >= divisor
        while(tempVal < divisor && idx < dStr.length - 1) {
            idx++;
            tempVal = parseInt(dStr.substring(0, idx + 1));
        }
        
        this.state.dividendIndex = idx;
        this.state.workingValue = tempVal;

        this.grid = {}; 
        // Extra width for long remainders or signs
        this.cols = this.problemData.dividendStr.length + 4;
        
        this.setGridCell(1, 0, this.problemData.divisor, 'divisor');
        this.setGridCell(1, 1, '', 'bracket');
        const divStr = this.problemData.dividendStr;
        for(let i=0; i<divStr.length; i++) {
            this.setGridCell(1, i+2, divStr[i], 'dividend');
        }

        this.userInput = '';
        this.highlightStep('DIVIDE');
        this.render();
    }

    // --- Core Logic ---

    processInput() {
        if (!this.userInput) return;
        
        const val = parseInt(this.userInput);
        const st = this.state;
        const pd = this.problemData;
        let correct = false;
        let correctVal = 0;
        let nextStep = '';

        if (st.step === 'DIVIDE') {
            correctVal = Math.floor(st.workingValue / pd.divisor);
            if (val === correctVal) {
                this.setGridCell(0, 2 + st.dividendIndex, val.toString(), 'quotient');
                st.quotientDigit = val;
                nextStep = 'MULTIPLY';
                correct = true;
            } else {
                this.showError(`How many times does ${pd.divisor} go into ${st.workingValue}?`);
            }
        } 
        else if (st.step === 'MULTIPLY') {
            correctVal = pd.divisor * st.quotientDigit;
            if (val === correctVal) {
                this.writeNumberToGrid(val, st.currentRow, 2 + st.dividendIndex, 'subtract-line');
                
                const len = val.toString().length;
                const startCol = (2 + st.dividendIndex) - (len - 1);
                this.setGridCell(st.currentRow, startCol - 1, '−', 'minus-sign');

                st.subtractionVal = val;
                st.currentRow++; 
                nextStep = 'SUBTRACT';
                correct = true;
            } else {
                this.showError(`${pd.divisor} × ${st.quotientDigit} = ?`);
            }
        }
        else if (st.step === 'SUBTRACT') {
            correctVal = st.workingValue - st.subtractionVal;
            if (val === correctVal) {
                this.writeNumberToGrid(val, st.currentRow, 2 + st.dividendIndex);
                st.currentRemainder = correctVal;
                
                if (st.dividendIndex >= pd.dividendStr.length - 1) {
                    if (st.currentRemainder > 0) {
                        nextStep = 'REMAINDER';
                        correct = true;
                    } else {
                        this.finishProblem();
                        return;
                    }
                } else {
                    nextStep = 'BRING_DOWN';
                    correct = true;
                }
            } else {
                this.showError(`${st.workingValue} - ${st.subtractionVal} = ?`);
            }
        }
        else if (st.step === 'BRING_DOWN') {
            const nextIndex = st.dividendIndex + 1;
            const digitToBring = parseInt(pd.dividendStr[nextIndex]);
            
            if (val === digitToBring) {
                st.dividendIndex++;
                this.setGridCell(st.currentRow, 2 + st.dividendIndex, val.toString());
                st.workingValue = parseInt(st.currentRemainder.toString() + val.toString());
                st.currentRow++; 
                nextStep = 'DIVIDE';
                correct = true;
            } else {
                this.showError(`Bring down the next number: ${digitToBring}`);
            }
        }
        else if (st.step === 'REMAINDER') {
            correctVal = st.currentRemainder;
            if (val === correctVal) {
                const rCol = this.problemData.dividendStr.length + 2; 
                this.setGridCell(0, rCol, "R", 'remainder-label');
                this.writeNumberToGrid(val, 0, rCol + val.toString().length);
                this.finishProblem();
                return;
            } else {
                this.showError(`The remainder is ${st.currentRemainder}`);
            }
        }

        if (correct) {
            this.userInput = '';
            st.step = nextStep;
            this.updateFeedback('Correct!', 'correct');
            this.highlightStep(nextStep);
            this.render();
        }
    }

    finishProblem() {
        // Scoring Logic: (Level * 10) - Errors
        let points = (this.level * 10) - this.errors;
        if (points < 0) points = 0;
        
        this.score += points;
        this.scoreDisplay.textContent = this.score;
        this.finalScoreMsg.textContent = `+${points} Points`;
        this.problemNumber++;
        
        document.getElementById('success-overlay').style.display = 'flex';
    }

    // --- Grid Helpers ---

    setGridCell(r, c, text, type='') {
        if (!this.grid[r]) this.grid[r] = {};
        this.grid[r][c] = { text, type };
    }

    writeNumberToGrid(number, row, colEnd, type='') {
        const str = number.toString();
        for (let i = 0; i < str.length; i++) {
            const c = colEnd - (str.length - 1) + i;
            this.setGridCell(row, c, str[i], type);
        }
    }

    // --- Input Handling ---

    getExpectedLength() {
        const st = this.state;
        const pd = this.problemData;
        if (st.step === 'DIVIDE') return 1; 
        if (st.step === 'BRING_DOWN') return 1; 
        if (st.step === 'MULTIPLY') return (pd.divisor * st.quotientDigit).toString().length;
        if (st.step === 'SUBTRACT') return (st.workingValue - st.subtractionVal).toString().length;
        if (st.step === 'REMAINDER') return st.currentRemainder.toString().length;
        return 1;
    }

    handleInput(key) {
        const expectedLen = this.getExpectedLength();
        if (expectedLen === 1) {
            this.userInput = key; 
        } else {
            if (this.userInput.length >= expectedLen) return;
            this.userInput += key;
        }
        this.render(); 
    }

    clearInput() {
        this.userInput = this.userInput.slice(0, -1);
        this.render();
    }

    submitInput() {
        this.processInput();
    }

    skipProblem() {
        this.nextProblem();
        this.updateFeedback("Skipped", 'wrong');
    }

    // --- Rendering ---

    render() {
        this.stage.innerHTML = '';
        
        const gridRows = Object.keys(this.grid).map(Number);
        const maxRow = Math.max(...gridRows, this.state.currentRow);
        
        this.stage.style.gridTemplateColumns = `repeat(${this.cols}, var(--grid-cell-size))`;
        this.stage.style.gridTemplateRows = `repeat(${maxRow + 1}, 45px)`;

        // 1. Render Static Cells
        for (let r = 0; r <= maxRow; r++) {
            for (let c = 0; c < this.cols; c++) {
                const cellData = this.grid[r] && this.grid[r][c];
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                
                if (c === 1 && r === 1) cellDiv.classList.add('bracket-cell');
                if (r === 1 && c >= 2 && c < this.problemData.dividendStr.length + 2) cellDiv.classList.add('dividend-cell');
                
                if (cellData) {
                    cellDiv.textContent = cellData.text;
                    if (cellData.type.includes('subtract-line')) cellDiv.classList.add('subtract-line');
                    if (cellData.type.includes('remainder-label')) cellDiv.classList.add('remainder-label');
                    if (cellData.type.includes('minus-sign')) cellDiv.classList.add('minus-sign');
                }
                
                this.stage.appendChild(cellDiv);
            }
        }

        // 2. Logic to determine Target Input Area
        let targetRow = 0;
        let targetColEnd = 0;
        let expectedLength = this.getExpectedLength();

        const st = this.state;
        const pd = this.problemData;

        if (st.step === 'DIVIDE') {
            targetRow = 0;
            targetColEnd = 2 + st.dividendIndex;
        } 
        else if (st.step === 'MULTIPLY') {
            targetRow = st.currentRow;
            targetColEnd = 2 + st.dividendIndex;
        }
        else if (st.step === 'SUBTRACT') {
            targetRow = st.currentRow;
            targetColEnd = 2 + st.dividendIndex;
        }
        else if (st.step === 'BRING_DOWN') {
            targetRow = st.currentRow; 
            targetColEnd = 2 + st.dividendIndex + 1;
            
            const arrowRow = targetRow - 1;
            const arrowCol = targetColEnd;
            const arrowIndex = (arrowRow * this.cols) + arrowCol;
            if(this.stage.children[arrowIndex] && !this.stage.children[arrowIndex].textContent) {
                 this.stage.children[arrowIndex].textContent = "↓";
                 this.stage.children[arrowIndex].classList.add("arrow-hint");
            }
        }
        else if (st.step === 'REMAINDER') {
            targetRow = 0; 
            const remainderVal = st.currentRemainder;
            const rCol = pd.dividendStr.length + 2;
            
            const rIndex = (0 * this.cols) + rCol;
            if(this.stage.children[rIndex]) {
                this.stage.children[rIndex].textContent = "R";
                this.stage.children[rIndex].classList.add('remainder-label');
            }
            targetColEnd = rCol + expectedLength;
        }

        // 3. Render Empty Target Boxes
        for(let i=0; i<expectedLength; i++) {
            const digitPos = (expectedLength - 1) - i; 
            const col = targetColEnd - digitPos;
            const r = targetRow;
            
            const index = (r * this.cols) + col;
            const cells = this.stage.children;
            
            if (cells[index]) {
                cells[index].classList.add('active-target'); 
                
                if (i < this.userInput.length) {
                    cells[index].textContent = this.userInput[i];
                    cells[index].classList.add('preview-input');
                } else {
                    cells[index].textContent = ''; 
                }
            }
        }
    }

    showError(msg) {
        this.errors++;
        this.errorDisplay.textContent = this.errors;
        
        this.updateFeedback(msg, 'wrong');
        const previews = document.querySelectorAll('.preview-input');
        previews.forEach(p => p.classList.add('error'));
        
        setTimeout(() => {
            this.userInput = '';
            this.render();
        }, 800);
    }

    updateFeedback(msg, type='neutral') {
        this.feedback.textContent = msg;
        this.feedback.className = '';
        if (type === 'correct') this.feedback.classList.add('correct');
        if (type === 'wrong') this.feedback.classList.add('wrong');
    }

    highlightStep(stepName) {
        Object.values(this.badges).forEach(b => b.classList.remove('active'));
        const map = { 'DIVIDE': 'divide', 'MULTIPLY': 'multiply', 'SUBTRACT': 'subtract', 'BRING_DOWN': 'bring', 'REMAINDER': 'remainder' };
        if(this.badges[map[stepName]]) this.badges[map[stepName]].classList.add('active');

        const st = this.state;
        const div = this.problemData.divisor;
        let hint = "";
        
        switch(stepName) {
            case 'DIVIDE': hint = `Divide: ${st.workingValue} ÷ ${div} = ?`; break;
            case 'MULTIPLY': hint = `Multiply: ${div} × ${st.quotientDigit} = ?`; break;
            case 'SUBTRACT': hint = `Subtract: ${st.workingValue} - ${st.subtractionVal} = ?`; break;
            case 'BRING_DOWN': hint = "Bring down the next number."; break;
            case 'REMAINDER': hint = "Enter the remainder."; break;
        }
        this.updateFeedback(hint);
    }
}

const game = new LongDivisionGame();

</script>
</body>
</html>
