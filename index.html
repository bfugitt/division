<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>System 6 - Long Division</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --input-focus-bg: #e3f2fd;
            --correct-color: #2ecc71;
            --wrong-color: #e74c3c;
            --grid-cell-size: 34px; 
            --border-thickness: 2px;
            --selected-cell-color: #b3e5fc;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(-45deg, #ccc 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #ccc 75%), 
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 4px 4px;
            user-select: none;
        }

        #game-container {
            background: white;
            border: 2px solid #000;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 550px;
            height: 95vh;
            display: flex;
            flex-direction: column;
            position: relative;
            box-sizing: border-box;
        }

        .title-bar {
            background: #000;
            color: #fff;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            border-bottom: 2px solid #000;
            flex-shrink: 0;
        }

        .title-bar .version { font-size: 0.9rem; color: #ccc; }

        .content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 15px;
            overflow: hidden;
        }

        .top-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            gap: 5px;
        }

        select.level-select, select.mode-select {
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            padding: 2px 5px;
            border: 2px solid #000;
            background: #eee;
            cursor: pointer;
        }
        
        button.toggle-btn {
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            background: #eee;
            border: 2px solid #000;
            cursor: pointer;
            padding: 2px 8px;
        }
        
        button.toggle-btn.active { background: #000; color: #fff; }

        .stats-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 1.4rem;
            border-bottom: 2px solid #000;
            padding-bottom: 5px;
            flex-shrink: 0;
        }

        .stat-box { display: flex; flex-direction: column; align-items: center; line-height: 1; }
        .stat-label { font-size: 0.9rem; color: #666; }
        .error-stat { color: var(--wrong-color); }

        .step-indicators {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            font-size: 1.1rem;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
            flex-shrink: 0;
            min-height: 24px; /* Preserve space even if hidden */
        }
        
        .step-badge {
            padding: 2px 6px;
            background: #eee;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #999;
        }
        
        .step-badge.active {
            background: #2c3e50;
            color: #fff;
            border-color: #000;
            font-weight: bold;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        #feedback-area {
            height: 40px;
            width: 100%;
            text-align: center;
            font-size: 1.3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f4f4f4;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            color: #555;
            padding: 0 10px;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        #feedback-area.correct { color: var(--correct-color); font-weight: bold; background: #e8f8f5; border-color: var(--correct-color); }
        #feedback-area.wrong { color: var(--wrong-color); font-weight: bold; background: #fdedec; border-color: var(--wrong-color); }

        #division-stage-container {
            flex-grow: 1;
            overflow: auto;
            border: 1px solid #eee;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        #division-stage {
            display: grid;
            gap: 0; 
            font-size: 1.8rem;
            background: #fff;
            padding: 10px;
        }

        .cell {
            width: var(--grid-cell-size);
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            box-sizing: border-box;
            cursor: default;
        }

        .cell.bracket-cell { border-right: var(--border-thickness) solid black; border-radius: 0 6px 0 0; margin-right: -1px; }
        .cell.dividend-cell { border-top: var(--border-thickness) solid black; margin-top: -1px; }
        .cell.subtract-line { border-bottom: var(--border-thickness) solid black; }
        .cell.minus-sign { font-weight: bold; color: #444; }
        .cell.arrow-hint { color: #2980b9; animation: bounce 1s infinite; font-size: 1.4rem; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }

        /* TRAINING MODE STYLES */
        .cell.active-target {
            background-color: var(--input-focus-bg);
            box-shadow: inset 0 0 0 2px #2196f3;
            border: 1px dashed #999; 
            margin: 1px;
            width: calc(var(--grid-cell-size) - 2px);
            height: calc(40px - 2px);
        }

        /* CHALLENGE MODE STYLES */
        .cell.challenge-cell {
            border: 1px solid #ddd;
            background: #fdfdfd;
            cursor: pointer;
            margin: 1px;
            width: calc(var(--grid-cell-size) - 2px);
            height: calc(40px - 2px);
        }
        .cell.challenge-cell.selected {
            background: var(--selected-cell-color);
            border: 2px solid #2196f3;
            font-weight: bold;
        }
        .cell.challenge-cell.user-filled {
            font-weight: bold;
            color: #000;
        }
        .cell.challenge-cell.checked-error {
            background: #fadbd8;
            color: var(--wrong-color);
            border-color: var(--wrong-color);
        }
        .cell.challenge-cell.revealed {
            color: var(--wrong-color);
            font-weight: bold;
        }
        
        .cell.preview-input { color: #000; font-weight: bold; background-color: #fff; }
        .cell.preview-input.error { color: var(--wrong-color); background-color: #fadbd8; }
        .cell.remainder-label { font-size: 1.4rem; color: #666; font-weight: bold; }

        #keypad {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            width: 100%;
            max-width: 320px;
            margin: 0 auto 10px auto;
            flex-shrink: 0;
        }

        .key {
            background: #e0e0e0;
            border: 1px solid #999;
            border-bottom: 3px solid #777;
            padding: 10px;
            font-size: 1.5rem;
            cursor: pointer;
            text-align: center;
            border-radius: 4px;
        }
        .key:active { transform: translateY(2px); border-bottom: 1px solid #777; background: #d5d5d5; }
        .key.action { background: #d4e6f1; border-color: #a9cce3; border-bottom-color: #5499c7; }
        .key.clear { background: #fadbd8; border-color: #e6b0aa; border-bottom-color: #cd6155; }

        .bottom-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        
        .btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 4px;
        }
        .btn-check { background: #d35400; }
        .btn-submit { background: #27ae60; }
        .btn:disabled { background: #999; cursor: not-allowed; opacity: 0.7; }

        #modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.2);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .retro-window {
            background: #fff;
            border: 2px solid #000;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.5);
            padding: 0;
            width: 300px;
            display: flex;
            flex-direction: column;
        }

        .retro-title {
            background: #000;
            color: #fff;
            padding: 5px 10px;
            font-size: 1.2rem;
            display: flex;
            justify-content: space-between;
        }

        .retro-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .retro-content h2 { margin: 0 0 10px 0; color: #27ae60; font-size: 2.5rem; }
        .retro-content p { font-size: 1.5rem; margin: 0 0 20px 0; }

    </style>
</head>
<body>

    <div id="game-container">
        <div class="title-bar">
            <span>System 6 Division</span>
            <span class="version">v2.0</span>
        </div>

        <div id="modal-overlay">
            <div class="retro-window">
                <div class="retro-title">
                    <span>Summary</span>
                    <span style="cursor:pointer;" onclick="game.nextProblem()">x</span>
                </div>
                <div class="retro-content">
                    <h2 id="modal-title">DONE!</h2>
                    <p id="final-score-msg">+10 Points</p>
                    <button class="btn" style="font-size: 1.2rem; padding: 10px 20px;" onclick="game.nextProblem()">Next Problem ▶</button>
                </div>
            </div>
        </div>

        <div class="content-area">
            <div class="top-controls">
                <button id="keypad-toggle" class="toggle-btn" onclick="game.toggleKeypad()">Keypad</button>
                <select id="mode-select" class="mode-select" onchange="game.changeMode()">
                    <option value="TRAINING">Training Mode</option>
                    <option value="CHALLENGE">Challenge Mode</option>
                </select>
                <select id="level-select" class="level-select" onchange="game.changeLevel()">
                    <option value="1">Lvl 1</option>
                    <option value="2">Lvl 2</option>
                    <option value="3">Lvl 3</option>
                    <option value="4">Lvl 4</option>
                </select>
            </div>

            <div class="stats-header">
                <div class="stat-box">
                    <span class="stat-label">PROBLEM</span>
                    <span id="problem-count">1</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">ERRORS</span>
                    <span id="error-display" class="error-stat">0</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">SCORE</span>
                    <span id="score-display">0</span>
                </div>
            </div>

            <div class="step-indicators" id="step-indicators">
                <div class="step-badge" id="badge-divide">÷ DIVIDE</div>
                <div class="step-badge" id="badge-multiply">× MULTIPLY</div>
                <div class="step-badge" id="badge-subtract">− SUBTRACT</div>
                <div class="step-badge" id="badge-bring">↓ BRING</div>
                <div class="step-badge" id="badge-remainder">R REMAINDER</div>
            </div>

            <div id="feedback-area">Loading...</div>

            <div id="division-stage-container">
                <div id="division-stage"></div>
            </div>

            <div id="keypad">
                <div class="key" onclick="game.handleInput('1')">1</div>
                <div class="key" onclick="game.handleInput('2')">2</div>
                <div class="key" onclick="game.handleInput('3')">3</div>
                <div class="key" onclick="game.handleInput('4')">4</div>
                <div class="key" onclick="game.handleInput('5')">5</div>
                <div class="key" onclick="game.handleInput('6')">6</div>
                <div class="key" onclick="game.handleInput('7')">7</div>
                <div class="key" onclick="game.handleInput('8')">8</div>
                <div class="key" onclick="game.handleInput('9')">9</div>
                <div class="key clear" onclick="game.clearInput()">DEL</div>
                <div class="key" onclick="game.handleInput('0')">0</div>
                <div class="key action" onclick="game.submitInput()">ENTER</div>
            </div>
            
            <div class="bottom-controls" id="controls-area">
                <!-- Dynamically populated based on mode -->
            </div>
        </div>
    </div>

<script>

class LongDivisionGame {
    constructor() {
        this.stage = document.getElementById('division-stage');
        this.feedback = document.getElementById('feedback-area');
        this.scoreDisplay = document.getElementById('score-display');
        this.errorDisplay = document.getElementById('error-display');
        this.problemCountDisplay = document.getElementById('problem-count');
        this.levelSelect = document.getElementById('level-select');
        this.modeSelect = document.getElementById('mode-select');
        this.finalScoreMsg = document.getElementById('final-score-msg');
        this.modalTitle = document.getElementById('modal-title');
        this.keypadElement = document.getElementById('keypad');
        this.keypadToggleBtn = document.getElementById('keypad-toggle');
        this.stepIndicators = document.getElementById('step-indicators');
        this.controlsArea = document.getElementById('controls-area');
        
        this.badges = {
            divide: document.getElementById('badge-divide'),
            multiply: document.getElementById('badge-multiply'),
            subtract: document.getElementById('badge-subtract'),
            bring: document.getElementById('badge-bring'),
            remainder: document.getElementById('badge-remainder')
        };
        
        this.score = 0;
        this.problemNumber = 1;
        this.level = 1;
        this.errors = 0;
        this.mode = 'TRAINING'; // TRAINING or CHALLENGE
        
        // Training Mode State
        this.userInput = ''; 
        
        // Challenge Mode State
        this.challengeGrid = {}; // Stores user answers: { "r,c": "val" }
        this.selectedCell = null; // {r, c}
        
        this.keypadVisible = false;
        
        this.init();
        this.setupKeyboard();
    }

    init() {
        this.nextProblem();
    }

    toggleKeypad() {
        this.keypadVisible = !this.keypadVisible;
        if (this.keypadVisible) {
            this.keypadElement.style.display = 'grid';
            this.keypadToggleBtn.classList.add('active');
        } else {
            this.keypadElement.style.display = 'none';
            this.keypadToggleBtn.classList.remove('active');
        }
    }

    setupKeyboard() {
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('modal-overlay').style.display === 'flex') {
                if (e.key === 'Enter') this.nextProblem();
                return;
            }

            if (e.key >= '0' && e.key <= '9') {
                this.handleInput(e.key);
            } else if (e.key === 'Enter') {
                this.submitInput();
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
                this.clearInput();
            }
        });
    }

    changeLevel() {
        this.level = parseInt(this.levelSelect.value);
        this.problemNumber = 1;
        this.score = 0;
        this.scoreDisplay.textContent = '0';
        this.nextProblem();
    }

    changeMode() {
        this.mode = this.modeSelect.value;
        this.problemNumber = 1;
        this.score = 0;
        this.scoreDisplay.textContent = '0';
        
        if (this.mode === 'CHALLENGE') {
            this.stepIndicators.style.visibility = 'hidden';
            this.updateFeedback("Fill in the boxes. Good Luck!");
        } else {
            this.stepIndicators.style.visibility = 'visible';
        }
        
        this.nextProblem();
    }

    generateProblem() {
        let divMin, divMax, dMin, dMax;
        
        switch(this.level) {
            case 1: dMin = 2; dMax = 9; divMin = 20; divMax = 99; break;
            case 2: dMin = 2; dMax = 9; divMin = 100; divMax = 999; break;
            case 3: dMin = 2; dMax = 9; divMin = 1000; divMax = 9999; break;
            case 4: dMin = 10; dMax = 25; divMin = 1000; divMax = 9999; break;
            default: dMin = 2; dMax = 9; divMin = 20; divMax = 99;
        }

        const divisor = Math.floor(Math.random() * (dMax - dMin + 1)) + dMin;
        const dividend = Math.floor(Math.random() * (divMax - divMin + 1)) + divMin;
        
        if (dividend < divisor * 2) return this.generateProblem();

        return {
            divisor: divisor,
            dividend: dividend,
            dividendStr: dividend.toString()
        };
    }

    // Pre-calculates the entire grid solution for Challenge Mode
    solveProblemInternal(problemData) {
        let solutionGrid = {};
        
        // Setup initial state similar to game
        let state = {
            dividendIndex: 0,
            currentRemainder: 0,
            workingValue: 0,
            currentRow: 2
        };
        
        // Initial Grid Setup
        const setCell = (r, c, txt, type='') => {
            if(!solutionGrid[r]) solutionGrid[r] = {};
            solutionGrid[r][c] = { text: txt.toString(), type: type };
        };

        const writeNum = (num, r, cEnd, type='') => {
            const str = num.toString();
            for(let i=0; i<str.length; i++) {
                setCell(r, cEnd - (str.length-1) + i, str[i], type);
            }
        };

        // Static Problem setup
        setCell(1, 0, problemData.divisor, 'divisor');
        setCell(1, 1, '', 'bracket');
        for(let i=0; i<problemData.dividendStr.length; i++) {
            setCell(1, i+2, problemData.dividendStr[i], 'dividend');
        }

        // Run Logic Loop
        let tempVal = 0;
        let idx = -1;
        const dStr = problemData.dividendStr;
        const divisor = problemData.divisor;

        // Start
        while(tempVal < divisor && idx < dStr.length - 1) {
            idx++;
            tempVal = parseInt(dStr.substring(0, idx + 1));
        }
        state.dividendIndex = idx;
        state.workingValue = tempVal;

        let finished = false;
        
        while(!finished) {
            // DIVIDE
            let quotientDigit = Math.floor(state.workingValue / divisor);
            setCell(0, 2 + state.dividendIndex, quotientDigit, 'quotient'); // Solution Cell
            
            // MULTIPLY
            let product = divisor * quotientDigit;
            writeNum(product, state.currentRow, 2 + state.dividendIndex, 'subtract-line'); // Solution Cells
            
            // Minus Sign
            let pLen = product.toString().length;
            setCell(state.currentRow, (2 + state.dividendIndex) - (pLen - 1) - 1, '−', 'minus-sign');
            
            state.currentRow++;
            
            // SUBTRACT
            let remainder = state.workingValue - product;
            writeNum(remainder, state.currentRow, 2 + state.dividendIndex); // Solution Cells
            state.currentRemainder = remainder;
            
            // CHECK NEXT
            if (state.dividendIndex >= dStr.length - 1) {
                // REMAINDER?
                if (state.currentRemainder > 0) {
                    let rCol = dStr.length + 2;
                    setCell(0, rCol, 'R', 'remainder-label');
                    writeNum(state.currentRemainder, 0, rCol + state.currentRemainder.toString().length);
                }
                finished = true;
            } else {
                // BRING DOWN
                state.dividendIndex++;
                let broughtDigit = parseInt(dStr[state.dividendIndex]);
                setCell(state.currentRow, 2 + state.dividendIndex, broughtDigit); // Solution Cell
                
                // New Working Value
                state.workingValue = parseInt(state.currentRemainder.toString() + broughtDigit.toString());
                
                // No row increment for bring down (it sits next to subtraction result usually)
                // But in this logic, we brought it down to the same row as subtraction result
                // Next multiply goes on NEW row
                state.currentRow++;
            }
        }
        
        return solutionGrid;
    }

    nextProblem() {
        document.getElementById('modal-overlay').style.display = 'none';
        this.problemData = this.generateProblem();
        this.problemCountDisplay.textContent = this.problemNumber;
        this.errors = 0;
        this.errorDisplay.textContent = this.errors;
        
        // Generate Solution for both modes (used for structure in Challenge, logic in Training)
        this.solutionGrid = this.solveProblemInternal(this.problemData);
        this.cols = this.problemData.dividendStr.length + 4;
        
        if (this.mode === 'TRAINING') {
            this.initTrainingMode();
        } else {
            this.initChallengeMode();
        }
    }

    // ================= TRAINING MODE =================
    
    initTrainingMode() {
        this.updateFeedback("Training: Follow the steps.");
        this.controlsArea.innerHTML = `<button class="btn" onclick="game.skipProblem()">Skip Problem</button>`;
        
        this.state = {
            step: 'DIVIDE', 
            dividendIndex: 0,
            currentRemainder: 0,
            workingValue: 0, 
            currentRow: 2 
        };

        // Initialize Training State Logic
        let tempVal = 0;
        let idx = -1;
        const dStr = this.problemData.dividendStr;
        const divisor = this.problemData.divisor;

        while(tempVal < divisor && idx < dStr.length - 1) {
            idx++;
            tempVal = parseInt(dStr.substring(0, idx + 1));
        }
        this.state.dividendIndex = idx;
        this.state.workingValue = tempVal;

        this.grid = {}; 
        this.setGridCell(1, 0, this.problemData.divisor, 'divisor');
        this.setGridCell(1, 1, '', 'bracket');
        const divStr = this.problemData.dividendStr;
        for(let i=0; i<divStr.length; i++) {
            this.setGridCell(1, i+2, divStr[i], 'dividend');
        }

        this.userInput = '';
        this.highlightStep('DIVIDE');
        this.render();
    }

    // ================= CHALLENGE MODE =================

    initChallengeMode() {
        this.updateFeedback("Challenge: Fill in the boxes!");
        this.controlsArea.innerHTML = `
            <button class="btn btn-check" onclick="game.checkWork()">Check Work</button>
            <button class="btn btn-submit" onclick="game.submitAnswer()">Submit Answer</button>
            <button class="btn" onclick="game.skipProblem()">Skip</button>
        `;
        
        this.challengeGrid = {}; // Reset user answers
        this.selectedCell = null;
        this.render();
    }

    checkWork() {
        // Highlight errors but don't fix them
        // Re-render will apply 'checked-error' class
        this.checked = true;
        this.render();
        
        // Count errors for feedback (optional)
        let errorCount = 0;
        const gridRows = Object.keys(this.solutionGrid).map(Number);
        const maxRow = Math.max(...gridRows);
        for(let r=0; r<=maxRow; r++) {
            if(!this.solutionGrid[r]) continue;
            for(let c in this.solutionGrid[r]) {
                const sol = this.solutionGrid[r][c];
                // Only check interactive cells (digits)
                const isDigit = /^[0-9]+$/.test(sol.text);
                if(isDigit && sol.type !== 'divisor' && sol.type !== 'dividend') {
                    const key = `${r},${c}`;
                    const userVal = this.challengeGrid[key];
                    if (userVal && userVal !== sol.text) errorCount++;
                }
            }
        }
        
        if (errorCount > 0) {
            this.updateFeedback(`${errorCount} errors found. Keep trying!`, 'wrong');
        } else {
            this.updateFeedback("Looks good so far!", 'correct');
        }
    }

    submitAnswer() {
        let allCorrect = true;
        
        const gridRows = Object.keys(this.solutionGrid).map(Number);
        const maxRow = Math.max(...gridRows);
        
        for(let r=0; r<=maxRow; r++) {
            if(!this.solutionGrid[r]) continue;
            for(let c in this.solutionGrid[r]) {
                const sol = this.solutionGrid[r][c];
                const isDigit = /^[0-9]+$/.test(sol.text);
                
                // We only care about user-fillable fields (quotient, products, subtraction results)
                // Divisor and Dividend are static
                if(isDigit && sol.type !== 'divisor' && sol.type !== 'dividend') {
                    const key = `${r},${c}`;
                    const userVal = this.challengeGrid[key];
                    if (userVal !== sol.text) {
                        allCorrect = false;
                    }
                }
            }
        }

        if (allCorrect) {
            this.modalTitle.textContent = "CORRECT!";
            this.modalTitle.style.color = "#27ae60";
            // Double points for challenge mode
            let points = (this.level * 20); 
            this.score += points;
            this.finalScoreMsg.textContent = `+${points} Points (Challenge Bonus!)`;
            this.scoreDisplay.textContent = this.score;
            document.getElementById('modal-overlay').style.display = 'flex';
        } else {
            this.modalTitle.textContent = "NICE TRY";
            this.modalTitle.style.color = "#e74c3c";
            this.finalScoreMsg.textContent = "Here is the correct solution.";
            
            // Reveal Answers
            this.revealed = true;
            this.render();
            
            // Wait a moment then show modal to move on? 
            // Or just change buttons to "Next"
            this.controlsArea.innerHTML = `<button class="btn btn-submit" onclick="game.nextProblem()">Next Problem</button>`;
            this.updateFeedback("Review the solution below.", 'wrong');
        }
    }

    handleChallengeInput(key) {
        if (!this.selectedCell || this.revealed) return;
        const mapKey = `${this.selectedCell.r},${this.selectedCell.c}`;
        this.challengeGrid[mapKey] = key; // Overwrite single digit
        this.checked = false; // Clear error highlights on edit
        this.render();
    }

    selectCell(r, c) {
        if (this.revealed) return;
        this.selectedCell = {r, c};
        this.render();
    }

    // ================= SHARED INPUT =================

    handleInput(key) {
        if (this.mode === 'CHALLENGE') {
            this.handleChallengeInput(key);
        } else {
            this.handleTrainingInput(key);
        }
    }

    clearInput() {
        if (this.mode === 'CHALLENGE') {
            if(this.selectedCell && !this.revealed) {
                const mapKey = `${this.selectedCell.r},${this.selectedCell.c}`;
                delete this.challengeGrid[mapKey];
                this.render();
            }
        } else {
            this.userInput = this.userInput.slice(0, -1);
            this.render();
        }
    }

    submitInput() {
        if (this.mode === 'CHALLENGE') {
            // Enter key acts like submit answer? Or maybe just moves selection?
            // Let's make it submit answer for convenience
            // this.submitAnswer(); 
            // Actually, safer to let them click the button so they don't accidentally submit partial work
        } else {
            this.processTrainingInput();
        }
    }

    skipProblem() {
        this.nextProblem();
        this.updateFeedback("Skipped", 'wrong');
    }

    // ================= TRAINING LOGIC =================
    
    handleTrainingInput(key) {
        const expectedLen = this.getExpectedLength();
        if (expectedLen === 1) {
            this.userInput = key; 
        } else {
            if (this.userInput.length >= expectedLen) return;
            this.userInput += key;
        }
        this.render(); 
    }

    processTrainingInput() {
        if (!this.userInput) return;
        const val = parseInt(this.userInput);
        const st = this.state;
        const pd = this.problemData;
        let correct = false;
        let nextStep = '';

        if (st.step === 'DIVIDE') {
            let correctVal = Math.floor(st.workingValue / pd.divisor);
            if (val === correctVal) {
                this.setGridCell(0, 2 + st.dividendIndex, val.toString(), 'quotient');
                st.quotientDigit = val;
                nextStep = 'MULTIPLY';
                correct = true;
            } else { this.showError(`How many times does ${pd.divisor} go into ${st.workingValue}?`); }
        } 
        else if (st.step === 'MULTIPLY') {
            let correctVal = pd.divisor * st.quotientDigit;
            if (val === correctVal) {
                this.writeNumberToGrid(val, st.currentRow, 2 + st.dividendIndex, 'subtract-line');
                const len = val.toString().length;
                const startCol = (2 + st.dividendIndex) - (len - 1);
                this.setGridCell(st.currentRow, startCol - 1, '−', 'minus-sign');
                st.subtractionVal = val;
                st.currentRow++; 
                nextStep = 'SUBTRACT';
                correct = true;
            } else { this.showError(`${pd.divisor} × ${st.quotientDigit} = ?`); }
        }
        else if (st.step === 'SUBTRACT') {
            let correctVal = st.workingValue - st.subtractionVal;
            if (val === correctVal) {
                this.writeNumberToGrid(val, st.currentRow, 2 + st.dividendIndex);
                st.currentRemainder = correctVal;
                if (st.dividendIndex >= pd.dividendStr.length - 1) {
                    if (st.currentRemainder > 0) { nextStep = 'REMAINDER'; correct = true; }
                    else { this.finishProblem(); return; }
                } else { nextStep = 'BRING_DOWN'; correct = true; }
            } else { this.showError(`${st.workingValue} - ${st.subtractionVal} = ?`); }
        }
        else if (st.step === 'BRING_DOWN') {
            const nextIndex = st.dividendIndex + 1;
            const digitToBring = parseInt(pd.dividendStr[nextIndex]);
            if (val === digitToBring) {
                st.dividendIndex++;
                this.setGridCell(st.currentRow, 2 + st.dividendIndex, val.toString());
                st.workingValue = parseInt(st.currentRemainder.toString() + val.toString());
                st.currentRow++; 
                nextStep = 'DIVIDE';
                correct = true;
            } else { this.showError(`Bring down the next number: ${digitToBring}`); }
        }
        else if (st.step === 'REMAINDER') {
            if (val === st.currentRemainder) {
                const rCol = this.problemData.dividendStr.length + 2; 
                this.setGridCell(0, rCol, "R", 'remainder-label');
                this.writeNumberToGrid(val, 0, rCol + val.toString().length);
                this.finishProblem();
                return;
            } else { this.showError(`The remainder is ${st.currentRemainder}`); }
        }

        if (correct) {
            this.userInput = '';
            st.step = nextStep;
            this.updateFeedback('Correct!', 'correct');
            this.highlightStep(nextStep);
            this.render();
        }
    }

    setGridCell(r, c, text, type='') {
        if (!this.grid[r]) this.grid[r] = {};
        this.grid[r][c] = { text, type };
    }

    writeNumberToGrid(number, row, colEnd, type='') {
        const str = number.toString();
        for (let i = 0; i < str.length; i++) {
            const c = colEnd - (str.length - 1) + i;
            this.setGridCell(row, c, str[i], type);
        }
    }

    getExpectedLength() {
        const st = this.state;
        const pd = this.problemData;
        if (st.step === 'DIVIDE') return 1; 
        if (st.step === 'BRING_DOWN') return 1; 
        if (st.step === 'MULTIPLY') return (pd.divisor * st.quotientDigit).toString().length;
        if (st.step === 'SUBTRACT') return (st.workingValue - st.subtractionVal).toString().length;
        if (st.step === 'REMAINDER') return st.currentRemainder.toString().length;
        return 1;
    }

    finishProblem() {
        let points = (this.level * 10) - this.errors;
        if (points < 0) points = 0;
        this.score += points;
        this.finalScoreMsg.textContent = `+${points} Points`;
        this.scoreDisplay.textContent = this.score;
        this.modalTitle.textContent = "DONE!";
        this.modalTitle.style.color = "#27ae60";
        document.getElementById('modal-overlay').style.display = 'flex';
    }

    showError(msg) {
        this.errors++;
        this.errorDisplay.textContent = this.errors;
        this.updateFeedback(msg, 'wrong');
        const previews = document.querySelectorAll('.preview-input');
        previews.forEach(p => p.classList.add('error'));
        setTimeout(() => { this.userInput = ''; this.render(); }, 800);
    }

    updateFeedback(msg, type='neutral') {
        this.feedback.textContent = msg;
        this.feedback.className = '';
        if (type === 'correct') this.feedback.classList.add('correct');
        if (type === 'wrong') this.feedback.classList.add('wrong');
    }

    highlightStep(stepName) {
        Object.values(this.badges).forEach(b => b.classList.remove('active'));
        const map = { 'DIVIDE': 'divide', 'MULTIPLY': 'multiply', 'SUBTRACT': 'subtract', 'BRING_DOWN': 'bring', 'REMAINDER': 'remainder' };
        if(this.badges[map[stepName]]) this.badges[map[stepName]].classList.add('active');

        const st = this.state;
        const div = this.problemData.divisor;
        let hint = "";
        
        switch(stepName) {
            case 'DIVIDE': hint = `Divide: ${st.workingValue} ÷ ${div} = ?`; break;
            case 'MULTIPLY': hint = `Multiply: ${div} × ${st.quotientDigit} = ?`; break;
            case 'SUBTRACT': hint = `Subtract: ${st.workingValue} - ${st.subtractionVal} = ?`; break;
            case 'BRING_DOWN': hint = "Bring down the next number."; break;
            case 'REMAINDER': hint = "Enter the remainder."; break;
        }
        this.updateFeedback(hint);
    }

    // ================= RENDERING =================

    render() {
        this.stage.innerHTML = '';
        
        if (this.mode === 'TRAINING') {
            this.renderTrainingMode();
        } else {
            this.renderChallengeMode();
        }
        
        // Auto-scroll
        const container = document.getElementById('division-stage-container');
        if (container.scrollHeight > container.clientHeight) {
            container.scrollTop = container.scrollHeight;
        }
    }

    renderChallengeMode() {
        // We use the PRE-CALCULATED Solution Grid to draw the board
        const gridRows = Object.keys(this.solutionGrid).map(Number);
        const maxRow = Math.max(...gridRows);
        
        this.stage.style.gridTemplateColumns = `repeat(${this.cols}, var(--grid-cell-size))`;
        this.stage.style.gridTemplateRows = `repeat(${maxRow + 1}, 40px)`;

        for (let r = 0; r <= maxRow; r++) {
            if (!this.solutionGrid[r]) continue;
            for (let c = 0; c < this.cols; c++) {
                const solData = this.solutionGrid[r][c]; // Correct data
                if (!solData) continue;

                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                
                // Styles
                if (c === 1 && r === 1) cellDiv.classList.add('bracket-cell');
                if (r === 1 && c >= 2 && c < this.problemData.dividendStr.length + 2) cellDiv.classList.add('dividend-cell');
                if (solData.type.includes('subtract-line')) cellDiv.classList.add('subtract-line');
                if (solData.type.includes('remainder-label')) cellDiv.classList.add('remainder-label');
                if (solData.type.includes('minus-sign')) cellDiv.classList.add('minus-sign');

                // Determine content logic
                const isStatic = solData.type === 'divisor' || solData.type === 'dividend' || solData.type === 'minus-sign' || solData.type === 'remainder-label';
                const isDigit = /^[0-9]+$/.test(solData.text);

                if (isStatic || !isDigit) {
                    // Static stuff always visible
                    cellDiv.textContent = solData.text;
                } else {
                    // INTERACTIVE BOX
                    cellDiv.classList.add('challenge-cell');
                    cellDiv.style.gridRow = parseInt(r) + 1;
                    cellDiv.style.gridColumn = parseInt(c) + 1;
                    
                    const mapKey = `${r},${c}`;
                    
                    // Interaction Handlers
                    cellDiv.onclick = () => this.selectCell(r, c);
                    
                    // Selected State
                    if (this.selectedCell && this.selectedCell.r == r && this.selectedCell.c == c) {
                        cellDiv.classList.add('selected');
                    }
                    
                    // Content Logic
                    if (this.revealed) {
                        // Show answer if revealed
                        const userVal = this.challengeGrid[mapKey];
                        if (userVal === solData.text) {
                            cellDiv.textContent = userVal;
                            cellDiv.classList.add('user-filled');
                        } else {
                            cellDiv.textContent = solData.text;
                            cellDiv.classList.add('revealed');
                        }
                    } else {
                        // Show user input
                        const userVal = this.challengeGrid[mapKey];
                        if (userVal) {
                            cellDiv.textContent = userVal;
                            cellDiv.classList.add('user-filled');
                            
                            // Check Work Error logic
                            if (this.checked && userVal !== solData.text) {
                                cellDiv.classList.add('checked-error');
                            }
                        }
                    }
                }
                
                // Positioning
                cellDiv.style.gridRow = parseInt(r) + 1;
                cellDiv.style.gridColumn = parseInt(c) + 1;
                
                this.stage.appendChild(cellDiv);
            }
        }
    }

    renderTrainingMode() {
        const gridRows = Object.keys(this.grid).map(Number);
        const maxRow = Math.max(...gridRows, this.state.currentRow);
        
        this.stage.style.gridTemplateColumns = `repeat(${this.cols}, var(--grid-cell-size))`;
        this.stage.style.gridTemplateRows = `repeat(${maxRow + 1}, 40px)`;

        // 1. Static Cells
        for (let r = 0; r <= maxRow; r++) {
            for (let c = 0; c < this.cols; c++) {
                const cellData = this.grid[r] && this.grid[r][c];
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                
                if (c === 1 && r === 1) cellDiv.classList.add('bracket-cell');
                if (r === 1 && c >= 2 && c < this.problemData.dividendStr.length + 2) cellDiv.classList.add('dividend-cell');
                
                if (cellData) {
                    cellDiv.textContent = cellData.text;
                    if (cellData.type.includes('subtract-line')) cellDiv.classList.add('subtract-line');
                    if (cellData.type.includes('remainder-label')) cellDiv.classList.add('remainder-label');
                    if (cellData.type.includes('minus-sign')) cellDiv.classList.add('minus-sign');
                }
                this.stage.appendChild(cellDiv);
            }
        }

        // 2. Logic Input
        let targetRow = 0;
        let targetColEnd = 0;
        let expectedLength = this.getExpectedLength();
        const st = this.state;
        const pd = this.problemData;

        if (st.step === 'DIVIDE') { targetRow = 0; targetColEnd = 2 + st.dividendIndex; } 
        else if (st.step === 'MULTIPLY') { targetRow = st.currentRow; targetColEnd = 2 + st.dividendIndex; }
        else if (st.step === 'SUBTRACT') { targetRow = st.currentRow; targetColEnd = 2 + st.dividendIndex; }
        else if (st.step === 'BRING_DOWN') {
            targetRow = st.currentRow; targetColEnd = 2 + st.dividendIndex + 1;
            const arrowIndex = ((targetRow-1) * this.cols) + targetColEnd;
            if(this.stage.children[arrowIndex] && !this.stage.children[arrowIndex].textContent) {
                 this.stage.children[arrowIndex].textContent = "↓";
                 this.stage.children[arrowIndex].classList.add("arrow-hint");
            }
        }
        else if (st.step === 'REMAINDER') {
            targetRow = 0; 
            const rCol = pd.dividendStr.length + 2;
            const rIndex = (0 * this.cols) + rCol;
            if(this.stage.children[rIndex]) {
                this.stage.children[rIndex].textContent = "R";
                this.stage.children[rIndex].classList.add('remainder-label');
            }
            targetColEnd = rCol + expectedLength;
        }

        for(let i=0; i<expectedLength; i++) {
            const digitPos = (expectedLength - 1) - i; 
            const col = targetColEnd - digitPos;
            const r = targetRow;
            const index = (r * this.cols) + col;
            const cells = this.stage.children;
            if (cells[index]) {
                cells[index].classList.add('active-target'); 
                if (i < this.userInput.length) {
                    cells[index].textContent = this.userInput[i];
                    cells[index].classList.add('preview-input');
                } else { cells[index].textContent = ''; }
            }
        }
    }
}

const game = new LongDivisionGame();

</script>
</body>
</html>
